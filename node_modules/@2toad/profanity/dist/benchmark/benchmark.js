"use strict";
/**
 * This script benchmarks the performance of the Profanity filter.
 *
 * Usage:
 * - To run the benchmark, execute: `npm run benchmark`
 *
 * Benchmarking:
 * - The benchmark script uses test data stored in `test-data.json`.
 * - The data is versioned so we can use the same test data across multiple benchmarking sessions.
 * - If you want to generate new random test data, increment TEST_VERSION before running the benchmark.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const benchmark_1 = require("benchmark");
const __1 = require("..");
const TEST_VERSION = 1;
const suite = new benchmark_1.Suite();
const testDataFile = path.join(__dirname, "test-data.json");
const createLargeString = (size, profanity) => {
    const words = profanity ? ["hello", "world", "arse", "shite", "damn", "bugger"] : ["hello", "world", "foo", "bar", "baz", "qux"];
    return Array.from({ length: size }, () => words[Math.floor(Math.random() * words.length)]).join(" ");
};
const generateTestData = () => ({
    smallCleanText: "Hello world, this is a clean text.",
    smallProfaneText: "Hello world, this is a damn profane text.",
    largeCleanText: createLargeString(1000, false),
    largeProfaneText: createLargeString(1000, true),
});
let fileData;
try {
    fileData = JSON.parse(fs.readFileSync(testDataFile, "utf-8"));
}
catch (error) {
    console.error("Error reading test data file:", error);
    process.exit(1);
}
const testData = fileData.versions.find((data) => data.version === TEST_VERSION) ||
    (() => {
        const newData = generateTestData();
        fileData.versions.push({ version: TEST_VERSION, ...newData });
        try {
            fs.writeFileSync(testDataFile, JSON.stringify(fileData, null, 2));
            console.log("Generated new test data");
        }
        catch (error) {
            console.error("Error writing test data file:", error);
            process.exit(1);
        }
        return newData;
    })();
console.log(`Using test data: v${TEST_VERSION}`);
const { smallCleanText, smallProfaneText, largeCleanText, largeProfaneText } = testData;
// Create Profanity instances for different scenarios
const defaultProfanity = new __1.Profanity();
const partialMatchProfanity = new __1.Profanity({ wholeWord: false });
// Pre-cache regexes
defaultProfanity.exists("foo");
partialMatchProfanity.exists("bar");
// Benchmark exists() function
suite
    .add("exists() - small clean text", () => {
    defaultProfanity.exists(smallCleanText);
})
    .add("exists() - small profane text", () => {
    defaultProfanity.exists(smallProfaneText);
})
    .add("exists() - large clean text", () => {
    defaultProfanity.exists(largeCleanText);
})
    .add("exists() - large profane text", () => {
    defaultProfanity.exists(largeProfaneText);
})
    .add("exists() - partial match, small profane text", () => {
    partialMatchProfanity.exists(smallProfaneText);
})
    // Benchmark censor() function
    .add("censor() - Word, small profane text", () => {
    defaultProfanity.censor(smallProfaneText, __1.CensorType.Word);
})
    .add("censor() - FirstChar, small profane text", () => {
    defaultProfanity.censor(smallProfaneText, __1.CensorType.FirstChar);
})
    .add("censor() - FirstVowel, small profane text", () => {
    defaultProfanity.censor(smallProfaneText, __1.CensorType.FirstVowel);
})
    .add("censor() - AllVowels, small profane text", () => {
    defaultProfanity.censor(smallProfaneText, __1.CensorType.AllVowels);
})
    .add("censor() - Word, large profane text", () => {
    defaultProfanity.censor(largeProfaneText, __1.CensorType.Word);
})
    .add("censor() - partial match, Word, small profane text", () => {
    partialMatchProfanity.censor(smallProfaneText, __1.CensorType.Word);
})
    // Run the benchmark
    .on("cycle", (event) => {
    console.log(String(event.target));
})
    .on("complete", function () {
    console.log(`Fastest: ${this.filter("fastest").map("name")[0]}`);
})
    .run({ async: true });
//# sourceMappingURL=benchmark.js.map